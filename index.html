<!DOCTYPE html>
<html lang="xx">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>THUUL'VOR KWEETH</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; touch-action: none; font-family: 'Courier New', monospace; }
        canvas { display: block; width: 100vw; height: 100vh; image-rendering: pixelated; filter: contrast(130%) brightness(140%) sepia(20%); }
        
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            background: radial-gradient(circle at center, transparent 20%, rgba(40,0,0,0.5) 70%, rgba(0,0,0,0.7) 100%); 
            animation: pulseOverlay 8s infinite alternate; }

        #scanlines { position: fixed; top:0; left:0; width:100%; height:100%; pointer-events:none;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.12), rgba(0,0,0,0.12) 1px, transparent 1px, transparent 5px); }

        #ui { position: absolute; top: 12px; left: 12px; color: #c00; text-shadow: 2px 2px #000; pointer-events: none; font-size: 16px; font-weight: bold; }
        #sanity-meter { width: 200px; height: 10px; background: #300; margin-top: 8px; border: 2px solid #600; }
        #sanity-fill { height: 100%; background: #f00; width: 100%; transition: width 0.4s; }

        .controls { position: absolute; bottom: 40px; right: 40px; display: grid; grid-template-columns: 70px 70px 70px; gap: 8px; }
        .btn { width: 70px; height: 70px; background: rgba(80,0,0,0.7); border: 2px solid #600; color: #c00; display: flex; align-items: center; justify-content: center; font-size: 32px; user-select: none; }
        
        #start-screen { position: fixed; top:0; left:0; width:100%; height:100%; background: linear-gradient(to bottom, #400 0%, #000 100%); color:#c00; display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:99; text-shadow: 0 0 10px #f00; animation: glitch 3s infinite; }
        #start-btn { padding: 30px 60px; border: 4px solid #c00; cursor: pointer; margin-top:40px; font-weight: bold; font-size: 28px; background: rgba(120,0,0,0.6); box-shadow: 0 0 20px #f00; border-radius: 8px; }
        
        @keyframes pulseOverlay { 0% { opacity: 0.6; } 100% { opacity: 0.9; } }
        @keyframes glitch { 0%,100% { transform: translate(0); } 10% { transform: translate(-2px,2px); } 20% { transform: translate(2px,-2px); } 30% { transform: translate(-2px,-2px); } 40% { transform: translate(2px,2px); } }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="font-size: 52px; animation: glitch 1.5s infinite;">THUUL'VOR KWEETH</h1>
        <p style="font-size: 22px;">GH'RNA KHUL'TAR OBRIGATORIUM</p>
        <p style="font-size: 20px;">SHUUB'EE VOR N'GHFT YA</p>
        <div id="start-btn">ENTRAR NO ABISMO</div>
    </div>

    <canvas id="render"></canvas>
    <div id="scanlines"></div>
    <div id="overlay"></div>

    <div id="ui">
        <div id="sanity-meter"><div id="sanity-fill"></div></div>
        <div id="debug" style="margin-top: 8px; font-size: 14px; color: #f00;"></div>
    </div>

    <div class="controls">
        <div></div><div class="btn" id="up">▲</div><div></div>
        <div class="btn" id="left">◀</div><div class="btn" id="down">▼</div><div class="btn" id="right">▶</div>
        <div></div><div></div><div></div>
    </div>

    <script>
        // ========================================================
        // AVISO OCULTO
        // thulgh-vor-666@simplelogin.com
        // ========================================================

        const canvas = document.getElementById('render');
        const ctx = canvas.getContext('2d');
        const sanityFill = document.getElementById('sanity-fill');
        const debugUI = document.getElementById('debug');
        
        const SIZE = 28;
        let map = new Array(SIZE * SIZE).fill(0);

        // Geração do mapa (igual à versão que você enviou)
        for (let y = 0; y < SIZE; y++) {
            for (let x = 0; x < SIZE; x++) {
                if (x === 0 || x === SIZE-1 || y === 0 || y === SIZE-1) {
                    map[y * SIZE + x] = 1;
                } else if (Math.random() > 0.65) {
                    map[y * SIZE + x] = 1;
                }
            }
        }
        // Área inicial livre
        for(let y=12; y<17; y++) for(let x=12; x<17; x++) map[y*SIZE+x] = 0;

        let p = { x: 14.5, y: 14.5, rot: Math.PI/2, san: 100, lightOn: true };
        let keys = {};
        let gameState = 'playing';

        let idleTimer = 0;

        const PILLARS = [
            {x: 15, y: 15},
            {x: 6,  y: 6},
            {x: 21, y: 21}
        ];
        let pillarIndex = 0;
        let pillarTimer = 0;

        const SHUUBEE_SPOTS = [
            {x:8, y:8}, {x:15,y:20}, {x:3,y:19}, {x:20,y:7}, {x:11,y:22}
        ];
        let shuubeeActive = false;
        let shuubeeTimer = 0;
        let shuubeeState = 0;

        let bloodTrails = [];

        let audioCtx, masterGain, droneOsc, whisperNode, morseOsc, morseGain;
        let screamOsc, screamGain, bizarreOsc, bizarreGain;

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.connect(audioCtx.destination);
            masterGain.gain.value = 0.75;

            droneOsc = audioCtx.createOscillator();
            droneOsc.type = 'sine';
            droneOsc.frequency.value = 42;
            let dGain = audioCtx.createGain();
            dGain.gain.value = 0.2;
            droneOsc.connect(dGain).connect(masterGain);
            droneOsc.start();

            morseOsc = audioCtx.createOscillator();
            morseOsc.type = 'square';
            morseOsc.frequency.value = 580;
            morseGain = audioCtx.createGain();
            morseGain.gain.value = 0;
            morseOsc.connect(morseGain).connect(masterGain);
            morseOsc.start();

            let bufSize = 8192;
            whisperNode = audioCtx.createScriptProcessor(bufSize, 1, 1);
            whisperNode.onaudioprocess = e => {
                let out = e.outputBuffer.getChannelData(0);
                for (let i = 0; i < bufSize; i++) {
                    out[i] = (Math.random()*2-1) * (Math.random() > 0.98 ? 0.7 : 0.08);
                }
            };
            let wFilter = audioCtx.createBiquadFilter();
            wFilter.type = 'bandpass';
            wFilter.frequency.value = 1600;
            let wGain = audioCtx.createGain();
            wGain.gain.value = 0.28;
            whisperNode.connect(wFilter).connect(wGain).connect(masterGain);

            screamOsc = audioCtx.createOscillator();
            screamOsc.type = 'sawtooth';
            screamOsc.frequency.value = 260;
            screamGain = audioCtx.createGain();
            screamGain.gain.value = 0;
            let sFilter = audioCtx.createBiquadFilter();
            sFilter.type = 'lowpass';
            sFilter.frequency.value = 850;
            screamOsc.connect(sFilter).connect(screamGain).connect(masterGain);
            screamOsc.start();

            bizarreOsc = audioCtx.createOscillator();
            bizarreOsc.type = 'triangle';
            bizarreOsc.frequency.value = 75;
            bizarreGain = audioCtx.createGain();
            bizarreGain.gain.value = 0;
            let bFilter = audioCtx.createBiquadFilter();
            bFilter.type = 'highpass';
            bFilter.frequency.value = 550;
            bizarreOsc.connect(bFilter).connect(bizarreGain).connect(masterGain);
            bizarreOsc.start();
        }

        function triggerScream(intensity = 0.45, duration = 2.2) {
            screamOsc.frequency.setValueAtTime(220 + Math.random()*300, audioCtx.currentTime);
            screamGain.gain.setValueAtTime(intensity, audioCtx.currentTime);
            screamGain.gain.exponentialRampToValueAtTime(0.003, audioCtx.currentTime + duration);
        }

        function triggerBizarre() {
            bizarreOsc.frequency.setValueAtTime(60 + Math.random()*500, audioCtx.currentTime);
            bizarreGain.gain.setValueAtTime(0.38, audioCtx.currentTime);
            bizarreGain.gain.exponentialRampToValueAtTime(0.005, audioCtx.currentTime + 0.9 + Math.random()*1.4);
        }

        const morseMsg = ".. -.- .... / ... .... ..- ..- -... . .----. . . / - .... ..- ..- .-.. .----. --. .... / --.. .- .-. .----. -.- .... ..- .-.. / -.- .-- . . - ....";
        let morseCharIndex = 0;
        let morseTimer = 0;

        function updateMorseVisualAndSound() {
            if (!shuubeeActive) return;

            morseTimer++;
            let char = morseMsg[morseCharIndex];

            if (char === '.') {
                shuubeeState = (morseTimer < 10) ? 1 : 0;
                morseGain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                morseGain.gain.setValueAtTime(0, audioCtx.currentTime + 0.08);
                if (morseTimer > 18) { morseCharIndex++; morseTimer = 0; }
            } else if (char === '-') {
                shuubeeState = (morseTimer < 28) ? 1 : 0;
                morseGain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                morseGain.gain.setValueAtTime(0, audioCtx.currentTime + 0.25);
                if (morseTimer > 38) { morseCharIndex++; morseTimer = 0; }
            } else if (char === ' ' || char === '/') {
                shuubeeState = 0;
                if (morseTimer > 30) { morseCharIndex++; morseTimer = 0; }
            }

            if (morseCharIndex >= morseMsg.length) morseCharIndex = 0;
        }

        function resize() {
            canvas.width = window.innerWidth / 2;
            canvas.height = window.innerHeight / 2;
        }
        window.onresize = resize; resize();

        const setupBtn = (id, key) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.ontouchstart = e => { e.preventDefault(); keys[key] = true; };
            el.ontouchend   = e => { e.preventDefault(); keys[key] = false; };
            el.onmousedown  = e => { e.preventDefault(); keys[key] = true; };
            el.onmouseup    = e => { e.preventDefault(); keys[key] = false; };
        };
        setupBtn('up', 'w'); setupBtn('down', 's');
        setupBtn('left', 'a'); setupBtn('right', 'd');

        window.onkeydown = e => keys[e.key.toLowerCase()] = true;
        window.onkeyup   = e => keys[e.key.toLowerCase()] = false;

        function update() {
            if (gameState !== 'playing') return;

            let speed = 0.07 * (p.san / 100);
            let rotSpeed = 0.055;

            let moved = false;

            if (keys['w']) { 
                p.x += Math.cos(p.rot) * speed; 
                p.y += Math.sin(p.rot) * speed; 
                moved = true;
                if (map[Math.floor(p.y)*SIZE + Math.floor(p.x)]) { 
                    p.x -= Math.cos(p.rot) * speed; 
                    p.y -= Math.sin(p.rot) * speed; 
                }
            }
            if (keys['s']) { 
                p.x -= Math.cos(p.rot) * speed; 
                p.y -= Math.sin(p.rot) * speed; 
                moved = true;
                if (Math.random() < 0.15 && p.san < 80) {
                    bloodTrails.push({x: p.x, y: p.y, life: 80 + Math.random()*60});
                }
                if (map[Math.floor(p.y)*SIZE + Math.floor(p.x)]) { 
                    p.x += Math.cos(p.rot) * speed; 
                    p.y += Math.sin(p.rot) * speed; 
                }
            }
            if (keys['a']) p.rot -= rotSpeed;
            if (keys['d']) p.rot += rotSpeed;

            if (!moved) idleTimer++;
            else idleTimer = 0;

            if (idleTimer > 480 && Math.random() < 0.008 + (idleTimer-480)/20000) {
                triggerScream(0.5 + idleTimer/4000, 2.5 + idleTimer/1200);
            }

            p.san = Math.max(0, Math.min(100, p.san + 0.08 - (p.san < 30 ? 0.04 : 0)));

            sanityFill.style.width = `${p.san}%`;
            if (p.san < 30) {
                sanityFill.style.background = `#\( {Math.floor(Math.random()*5)} \){Math.floor(Math.random()*3)}0`;
            } else {
                sanityFill.style.background = '#b00';
            }

            let px = Math.floor(p.x);
            let py = Math.floor(p.y);
            debugUI.innerText = `X: ${px}   Y: ${py}`;

            shuubeeActive = SHUUBEE_SPOTS.some(s => s.x === px && s.y === py);
            if (shuubeeActive) updateMorseVisualAndSound();
            else shuubeeState = 0;

            if (px === PILLARS[pillarIndex].x && py === PILLARS[pillarIndex].y) {
                pillarTimer++;
                droneOsc.frequency.setValueAtTime(42 + pillarTimer*0.15, audioCtx.currentTime);

                if (pillarTimer > 160) {
                    triggerScream(0.6, 1.2);
                    ctx.fillStyle = 'rgba(255,0,0,0.4)';
                    ctx.fillRect(0,0,canvas.width,canvas.height);
                    pillarIndex++;
                    pillarTimer = 0;

                    if (pillarIndex >= PILLARS.length) gameState = 'final_terror';
                }
            } else {
                pillarTimer = Math.max(0, pillarTimer - 2);
            }

            if (Math.random() < 0.025 && p.san < 70) triggerBizarre();
            if (Math.random() < 0.012 && p.san < 45) triggerScream(0.35, 1.8);

            bloodTrails = bloodTrails.filter(t => { t.life--; return t.life > 0; });
        }

        function draw() {
            if (gameState === 'final_terror') {
                let r = Math.random() > 0.4 ? 120 : 0;
                ctx.fillStyle = `rgb(${r},0,0)`;
                ctx.fillRect(0,0,canvas.width, canvas.height);

                ctx.fillStyle = '#f00';
                ctx.font = '28px Courier';
                ctx.fillText("THUUL'GH YA N'GHFT", 30, canvas.height/2 - 50);
                ctx.font = '20px Courier';
                ctx.fillText("ZAR'KHUL VOM KWEETH", 50, canvas.height/2);
                ctx.fillText("IKH SHUUB'EE N'GHAI VOR", 40, canvas.height/2 + 50);

                ctx.save();
                ctx.translate(Math.random()*6-3, Math.random()*6-3);
                if (Math.random() > 0.6) {
                    ctx.fillStyle = '#800';
                    ctx.fillRect(Math.random()*canvas.width, Math.random()*canvas.height, 40, 8);
                }
                ctx.restore();
                return;
            }

            if (p.san < 14 && Math.random() < 0.014) {
                ctx.fillStyle = 'rgba(220,0,0,0.85)';
                ctx.fillRect(0,0,canvas.width, canvas.height);
                ctx.fillStyle = '#000';
                ctx.font = 'bold 34px Courier';
                let msgs = ["GH'RNA YA N'GHFT", "SHUUB'EE VOR THUUL", "KWEETH N'GHAI YA", "ZAR'KHUL TEH"];
                ctx.fillText(msgs[Math.floor(Math.random()*msgs.length)], 40, canvas.height/2 + 20);
            }

            ctx.fillStyle = '#040404';
            ctx.fillRect(0,0,canvas.width, canvas.height);

            const rays = canvas.width;
            const fov = Math.PI / 3;

            for(let i = 0; i < rays; i++) {
                let angle = p.rot - fov/2 + (i/rays)*fov;
                let dist = 0, hit = 0;
                let step = 0.04;
                let rayX = Math.cos(angle), rayY = Math.sin(angle);

                while(dist < 15 && hit === 0) {
                    dist += step;
                    let tx = Math.floor(p.x + rayX*dist);
                    let ty = Math.floor(p.y + rayY*dist);
                    if (tx < 0 || tx >= SIZE || ty < 0 || ty >= SIZE) break;
                    if (map[ty*SIZE + tx] === 1) hit = 1;
                }

                let h = canvas.height / (dist * Math.cos(angle - p.rot));
                let fog = 1 - (dist/12); // Menos fog = mais visão

                let light = shuubeeActive ? (shuubeeState ? 2.0 : 0.4) : 1.5; // Luz base mais forte

                let floorYstart = (canvas.height + h) / 2;
                for (let y = floorYstart; y < canvas.height; y += 2) {
                    let fdist = canvas.height / (2*y - canvas.height);
                    let fx = p.x + rayX * fdist;
                    let fy = p.y + rayY * fdist;

                    let blood = Math.sin(fx*1.9) * Math.cos(fy*2.8) + Math.sin(fx*fy*0.7) + Math.random()*0.7;

                    let trailBlood = bloodTrails.some(t => Math.hypot(t.x - fx, t.y - fy) < 1.5 && t.life > 20);

                    let r,g,b;
                    if (blood > 0.25 || trailBlood) {
                        r = (180 + Math.random()*80) * fog * light;
                        g = (20 + Math.random()*40)  * fog * light;
                        b = (10 + Math.random()*40)  * fog * light;
                    } else {
                        r = 50 * fog * light;
                        g = 60 * fog * light;
                        b = 40 * fog * light;
                    }
                    ctx.fillStyle = `rgb(\( {r|0}, \){g|0},${b|0})`;
                    ctx.fillRect(i, y, 1, 2);
                }

                let wc = 110 * fog * light;
                if (p.san < 35) wc += Math.random()*50;
                ctx.fillStyle = `rgb(${wc|0}, ${wc/2|0}, ${wc/3|0})`;
                ctx.fillRect(i, (canvas.height-h)/2, 1, h);

                if (hit && Math.random() < 0.25 && p.san < 60) {
                    ctx.fillStyle = `rgb(220, 10, 10)`;
                    let len = Math.random() * h * 0.8;
                    ctx.fillRect(i, (canvas.height-h)/2 + Math.random()*(h-len), 1, len);
                }
            }

            if (p.san < 15) {
                ctx.save();
                ctx.translate(Math.random()*4-2, Math.random()*4-2);
                ctx.restore();
            }
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';
            initAudio();
            if (whisperNode && audioCtx) whisperNode.connect(audioCtx.destination);
            loop();
        });
    </script>
</body>
</html>
